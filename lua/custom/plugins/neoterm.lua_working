return {
  {
    dir = vim.fn.stdpath 'config' .. '/lua/custom',
    name = 'neoterm',
    config = function()
      local M = {}

      -- Load or create config file
      local function load_config()
        local config_path = vim.fn.stdpath 'data' .. '/neoterm_config.json'
        local f = io.open(config_path, 'r')
        if f then
          local content = f:read '*all'
          f:close()
          local ok, config = pcall(vim.json.decode, content)
          if ok then
            return config
          end
        end
        return { venv_name = 'venv' }
      end

      -- Save config to file
      local function save_config(config)
        local config_path = vim.fn.stdpath 'data' .. '/neoterm_config.json'
        local f = io.open(config_path, 'w')
        if f then
          f:write(vim.json.encode(config))
          f:close()
        end
      end

      -- Plugin state
      local state = {
        floating = {
          buf = -1, -- Buffer ID
          win = -1, -- Window ID
        },
        -- Virtual environment configuration
        venv = {
          name = load_config().venv_name, -- Load venv name from config
        },
      }

      -- Helper function to send commands to terminal
      local function send_to_terminal(bufnr, cmd)
        local chan = vim.api.nvim_buf_get_var(bufnr, 'terminal_job_id')
        vim.api.nvim_chan_send(chan, cmd .. '\n')
      end

      -- UI notification logic
      local function notify_venv_update(name, is_default)
        local message = is_default and 'No input provided - using default virtual environment name: ' .. name
          or 'Virtual environment name set to: ' .. name .. ' (saved for future sessions)'

        vim.schedule(function()
          vim.notify(message, vim.log.levels.INFO)
        end)
      end

      -- Venv name setting logic
      local function update_venv_name(name)
        state.venv.name = name
        save_config { venv_name = name }
        vim.cmd 'echo ""' -- Clear command line
      end

      -- Main configuration function
      local function configure_venv()
        local current_name = state.venv.name

        -- Get user input
        local input = vim.fn.input('Enter venv name: ', current_name, 'file')
        vim.cmd 'echo ""' -- Clear command line immediately after input

        -- Handle the input
        if input and input ~= '' then
          update_venv_name(input)
          notify_venv_update(input, false)
        else
          update_venv_name 'venv'
          notify_venv_update('venv', true)
        end
      end

      -- Command groups configuration
      local command_groups = {
        a = { name = 'Run a bash alias' },
        c = { name = 'Edit nvim-django-terminal configuration' },
        d = { name = 'Django commands' },
        v = { name = 'Virtual environment' },
      }

      -- Predefined terminal commands
      local term_commands = {
        -- Bash alias group
        ebal = {
          cmd = 'ebal',
          desc = 'Edit bash alias',
          keys = 'aa',
          group = 'a',
        },
        ebrc = {
          cmd = 'ebrc',
          desc = 'Edit bash rc',
          keys = 'ar',
          group = 'e',
        },
        -- Virtual environment group
        venvp = {
          cmd = function()
            return {
              init = vim.o.shell,
              post_cmd = string.format('cd ../ && source %s/bin/activate && cd -', state.venv.name),
            }
          end,
          desc = 'Activate a virtual environment located in parent directory',
          keys = 'vp',
          group = 'v',
        },
        venvw = {
          cmd = function()
            return {
              init = vim.o.shell,
              post_cmd = string.format('source %s/bin/activate', state.venv.name),
            }
          end,
          desc = 'Activate a virtual environment located in working directory',
          keys = 'vw',
          group = 'v',
        },
        -- Config group
        conf = {
          cmd = configure_venv,
          desc = 'Configure virtual environment folder name',
          keys = 'cn',
          group = 'c',
          no_term = true,
        },
      }

      -- Set up terminal buffer options
      local function setup_terminal(bufnr)
        -- Set buffer options
        vim.bo[bufnr].buflisted = false
        vim.bo[bufnr].modifiable = true
        vim.bo[bufnr].bufhidden = 'hide' -- Ensure the terminal is available, until its killed.

        -- Start terminal in insert mode
        vim.cmd 'startinsert'

        -- Auto-enter insert mode when focusing terminal
        local term_group = vim.api.nvim_create_augroup('TerminalBehavior', { clear = true })
        vim.api.nvim_create_autocmd('BufEnter', {
          group = term_group,
          buffer = bufnr,
          callback = function()
            if vim.bo[bufnr].buftype == 'terminal' then
              vim.cmd 'startinsert'
            end
          end,
        })
      end

      -- Create floating terminal window
      function M.create_float_term(opts)
        opts = opts or {}

        -- Get editor dimensions
        local width = vim.o.columns
        local height = vim.o.lines

        -- Calculate window dimensions (80% of screen)
        local win_width = opts.width or math.floor(width * 0.8)
        local win_height = opts.height or math.floor(height * 0.8)

        -- Calculate starting position to center the window
        local row = math.floor((height - win_height) / 2)
        local col = math.floor((width - win_width) / 2)

        -- Create or reuse buffer
        local buf = nil
        if vim.api.nvim_buf_is_valid(opts.buf) then
          buf = opts.buf
        else
          buf = vim.api.nvim_create_buf(false, true)
        end

        -- Window configuration
        local win_config = {
          relative = 'editor',
          width = win_width,
          height = win_height,
          row = row,
          col = col,
          style = 'minimal',
          border = 'rounded',
        }

        -- Create window
        local win = vim.api.nvim_open_win(buf, true, win_config)

        -- Set up terminal behavior if this is a new buffer
        if not vim.api.nvim_buf_is_valid(opts.buf) then
          setup_terminal(buf)
        end

        return {
          buf = buf,
          win = win,
        }
      end

      -- Function to run terminal command
      function M.run_command(command_name)
        local cmd = term_commands[command_name]
        if not cmd then
          vim.notify('Unknown command: ' .. command_name, vim.log.levels.ERROR)
          return
        end

        -- Handle non-terminal commands differently
        if cmd.no_term then
          if type(cmd.cmd) == 'function' then
            cmd.cmd()
          end
          return
        end

        -- Create or show terminal window
        if not vim.api.nvim_win_is_valid(state.floating.win) then
          state.floating = M.create_float_term { buf = state.floating.buf }

          -- Get the command configuration
          local command = type(cmd.cmd) == 'function' and cmd.cmd() or cmd.cmd

          -- If command is a table with init and post_cmd, handle specially
          if type(command) == 'table' and command.init then
            -- Create terminal with initial shell
            vim.fn.termopen(command.init, {
              env = {
                TERM = 'xterm-256color',
              },
            })

            -- Wait briefly for terminal to initialize
            vim.defer_fn(function()
              -- Send the post-initialization command
              if command.post_cmd then
                send_to_terminal(state.floating.buf, command.post_cmd)
              end
            end, 100) -- 100ms delay
          else
            -- Handle regular commands as before
            vim.fn.termopen(command, {
              env = {
                TERM = 'xterm-256color',
              },
            })
          end

          vim.cmd 'startinsert'
        else
          vim.api.nvim_win_hide(state.floating.win)
        end
      end

      -- Create base terminal command
      vim.api.nvim_create_user_command('Neoterm', function()
        if not vim.api.nvim_win_is_valid(state.floating.win) then
          state.floating = M.create_float_term { buf = state.floating.buf }
          if vim.bo[state.floating.buf].buftype ~= 'terminal' then
            vim.fn.termopen(vim.o.shell)
            vim.cmd 'startinsert'
          end
        else
          vim.api.nvim_win_hide(state.floating.win)
        end
      end, {
        desc = 'Open floating terminal',
      })

      -- Create command to set venv name
      vim.api.nvim_create_user_command('NeotermSetVenv', function(opts)
        update_venv_name(opts.args)
        notify_venv_update(opts.args, false)
      end, {
        desc = 'Set virtual environment directory name',
        nargs = 1,
      })

      -- Create commands for each predefined terminal command
      for name, cmd in pairs(term_commands) do
        vim.api.nvim_create_user_command('Neoterm' .. name:upper(), function()
          M.run_command(name)
        end, {
          desc = cmd.desc,
        })
      end

      -- Set up which-key mappings
      local ok, wk = pcall(require, 'which-key')
      if ok then
        -- Create base group mapping
        wk.add {
          { '<leader>n', name = '[N]eoterm' },
          { '<leader>nt', ':Neoterm<CR>', desc = 'Floating Terminal', mode = 'n' },
        }

        -- Register command groups
        for prefix, group_info in pairs(command_groups) do
          wk.add {
            { '<leader>n' .. prefix, group = group_info.name, mode = 'n' },
          }
        end

        -- Create mappings for each command
        for name, cmd in pairs(term_commands) do
          -- Use the specified keys or fall back to first letter of command name
          local key_sequence = cmd.keys or name:sub(1, 1)
          wk.add {
            { '<leader>n' .. key_sequence, ':Neoterm' .. name:upper() .. '<CR>', desc = cmd.desc, mode = 'n' },
          }
        end
      end
    end,
  },
}
